#!/usr/bin/python
"""
Author: Vertigo Designs, Ryan Summers
        Robert JÃ¶rdens

Description: Provides an API for controlling Miniconf devices over MQTT.
"""
import asyncio
import json
import logging
import uuid
import warnings

from gmqtt import Client

LOGGER = logging.getLogger(__name__)


class MiniconfException(Exception):
    """Generic exceptions generated by Miniconf."""


class Miniconf:
    """An asynchronous API for controlling Miniconf devices using MQTT."""

    @classmethod
    async def create(cls, client, prefix):
        """Create a connection to the broker and a Miniconf device using it."""
        if isinstance(client, str):
            client_ = Client(client_id="")
            await client_.connect(client)
            client = client_
        miniconf = cls(client, prefix)
        await miniconf.subscriptions_complete()
        return miniconf

    def __init__(self, client, prefix):
        """Constructor.

        Args:
            client: A connected MQTT5 client.
            prefix: The MQTT toptic prefix of the device to control.
        """
        self.client = client
        self.prefix = prefix
        self._inflight = {}
        self.client.on_message = self._on_message
        self.client.on_subscribe = self._on_subscribe
        self.response_topic = f"{prefix}/response"
        self._pending_subscriptions = {
            self.client.subscribe(
                self.response_topic
            ): asyncio.get_running_loop().create_future(),
        }

    async def subscriptions_complete(self):
        """Wait for all pending subscriptions to complete."""
        return await asyncio.gather(*self._pending_subscriptions.values())

    def _on_subscribe(self, _client, mid, _qos, _props):
        LOGGER.info("Handling subscription for %s", mid)
        if mid not in self._pending_subscriptions:
            LOGGER.warning("MID: %s, unexpected subscription", mid)
            return

        self._pending_subscriptions[mid].set_result(True)
        del self._pending_subscriptions[mid]

    def _on_message(self, _client, topic, payload, _qos, properties):
        """Callback function for when messages are received over MQTT.

        Args:
            _client: The MQTT client.
            topic: The topic that the message was received on.
            payload: The payload of the message.
            _qos: The quality-of-service level of the received packet
            properties: A dictionary of properties associated with the message.
        """
        # Extract request_id corrleation data from the properties
        try:
            request_id = properties["correlation_data"][0]
        except KeyError:
            LOGGER.info("Discarding message without CD")
            return

        try:
            ret, fut = self._inflight[request_id]
        except KeyError:
            LOGGER.info("Discarding message with unexpected CD: %s", request_id)
            return

        # When receiving data not on the specific response topic, the data is some partial result of
        # another response. Append it to the data collected for the request.
        if topic != self.response_topic:
            # Payloads for path values are JSON formatted.
            response = json.loads(payload)

            # Handle get subscription data.
            ret.append(response)
            return

        # Payloads for generic responses are UTF8
        response = payload.decode("utf-8")

        try:
            code = dict(properties["user_property"])["code"]
        except KeyError:
            LOGGER.warning("Discarding message without response code user property")
            return

        # Otherwise, a request has completed with a result. Check the result code and handle it
        # appropriately.
        if code == "Continue":
            ret.append(response)
            return

        if code == "Ok":
            if response:
                ret.append(response)
            fut.set_result(ret)
        else:
            fut.set_exception(
                MiniconfException(f"Received code: {code}, Message: {response}")
            )

        del self._inflight[request_id]

    async def _do(self, *args, **kwargs):
        fut = asyncio.get_running_loop().create_future()

        request_id = uuid.uuid1().hex.encode()
        assert request_id not in self._inflight
        self._inflight[request_id] = [], fut

        self.client.publish(
            *args,
            response_topic=self.response_topic,
            correlation_data=request_id,
            **kwargs,
        )
        return await fut

    async def command(self, *args, **kwargs):
        """Refer to `set()` for more information."""
        warnings.warn(
            "The `command` API function is deprecated in favor of `set()`",
            DeprecationWarning,
        )
        return await self.set(*args, **kwargs)

    async def set(self, path, value, retain=False):
        """Write the provided data to the specified path.

        Args:
            path: The path to set.
            value: The value to set.
            retain: Retain the the setting on the broker.
        """
        ret = await self._do(
            f"{self.prefix}/settings{path}",
            payload=json.dumps(value, separators=(",", ":")),
            retain=retain,
        )
        assert len(ret) == 1
        return ret[0]

    async def list_paths(self):
        """Get a list of all the paths available on the device."""
        return await self._do(f"{self.prefix}/list", payload="")

    async def get(self, path):
        """Get the specific value of a given path.

        Args:
            path: The path to get.
        """
        ret = await self._do(f"{self.prefix}/settings{path}", payload="")
        assert len(ret) == 1
        return ret[0]

    async def clear(self, path):
        """Clear retained value from a path.

        Args:
            path: The path to get.
        """
        await self._do(f"{self.prefix}/settings{path}", payload="", retain=True)
