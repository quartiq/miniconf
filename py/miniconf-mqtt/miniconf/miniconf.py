#!/usr/bin/python
"""
Author: Vertigo Designs, Ryan Summers
        Robert JÃ¶rdens

Description: Provides an API for controlling Miniconf devices over MQTT.
"""
import asyncio
import json
import logging
import uuid

from gmqtt import Client as MqttClient

LOGGER = logging.getLogger(__name__)

class MiniconfException(Exception):
    """ Generic exceptions generated by Miniconf. """


class Miniconf:
    """An asynchronous API for controlling Miniconf devices using MQTT."""

    @classmethod
    async def create(cls, prefix, broker):
        """Create a connection to the broker and a Miniconf device using it."""
        client = MqttClient(client_id='')
        await client.connect(broker)
        return cls(client, prefix)

    def __init__(self, client, prefix):
        """Constructor.

        Args:
            client: A connected MQTT5 client.
            prefix: The MQTT toptic prefix of the device to control.
        """
        self.client = client
        self.prefix = prefix
        self.inflight = {}
        self.client.on_message = self._handle_response
        self.command_response_topic = f'{prefix}/response/command'
        self.list_response_topic = f'{prefix}/response/list'
        self.get_response_topic = f'{prefix}/response/get'
        self.client.subscribe(f'{prefix}/response/#')
        self._topics = []

    def _handle_response(self, _client, topic, payload, _qos, properties):
        """Callback function for when messages are received over MQTT.

        Args:
            _client: The MQTT client.
            topic: The topic that the message was received on.
            payload: The payload of the message.
            _qos: The quality-of-service level of the received packet
            properties: A dictionary of properties associated with the message.
        """
        logging.info(f'Received message: {topic}={payload}')
        if topic in (self.command_response_topic, self.get_response_topic):
            # Extract request_id corrleation data from the properties
            request_id = properties['correlation_data'][0]

            if request_id not in self.inflight:
                LOGGER.info("Discarding message with CD: %s", request_id)
                return

            self.inflight[request_id].set_result(json.loads(payload))
            del self.inflight[request_id]

        elif topic == self.list_response_topic:
            if payload == b'':
                self.inflight['LIST'].set_result(self._topics)
                del self.inflight['LIST']
            else:
                self._topics.append(payload.decode('ascii'))

        else:
            LOGGER.warning('Unexpected message on "%s"', topic)

    async def command(self, path, value, retain=False, timeout=5):
        """Write the provided data to the specified path.

        Args:
            path: The path to write the message to.
            value: The value to write to the path.
            retain: Retain the MQTT message changing the setting
                by the broker.
            timeout: The maximum time to wait for the response in seconds.

        Returns:
            The response to the command as a dictionary.
        """
        topic = f'{self.prefix}/settings/{path}'

        fut = asyncio.get_running_loop().create_future()

        # Assign unique correlation data for response dispatch
        request_id = uuid.uuid1().hex.encode()
        assert request_id not in self.inflight
        self.inflight[request_id] = fut

        payload = json.dumps(value, separators=(",", ":"))
        LOGGER.info('Sending "%s" to "%s" with CD: %s', value, topic, request_id)

        self.client.publish(
            topic, payload=payload, qos=0, retain=retain,
            response_topic=self.response_topic,
            correlation_data=request_id)

        result = await asyncio.wait_for(fut, timeout)
        if result['code'] != 0:
            raise MiniconfException(result['msg'])

    async def list_paths(self, timeout=5.0):
        self._topics = []
        fut = asyncio.get_running_loop().create_future()

        assert 'LIST' not in self.inflight
        self.inflight['LIST'] = fut

        self.client.publish(f'{self.prefix}/list', payload='Test',
                            response_topic=self.list_response_topic)
        return await asyncio.wait_for(fut, timeout)


    async def get_value(self, path, timeout=5.0):
        fut = asyncio.get_running_loop().create_future()

        # Assign unique correlation data for response dispatch
        request_id = uuid.uuid1().hex.encode()
        assert request_id not in self.inflight
        self.inflight[request_id] = fut

        self.client.publish(
            f'{self.prefix}/get', payload=path, qos=0,
            response_topic=self.get_response_topic,
            correlation_data=request_id)

        return await asyncio.wait_for(fut, timeout)
