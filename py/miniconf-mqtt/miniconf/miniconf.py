#!/usr/bin/python
"""
Author: Vertigo Designs, Ryan Summers
        Robert JÃ¶rdens

Description: Provides an API for controlling Miniconf devices over MQTT.
"""
import asyncio
import json
import logging
import uuid
import warnings
import sys
import os

from aiomqtt import Client, Message
from paho.mqtt.properties import Properties, PacketTypes
import paho.mqtt
MQTTv5 = paho.mqtt.enums.MQTTProtocolVersion.MQTTv5

LOGGER = logging.getLogger(__name__)

if sys.platform.lower() == "win32" or os.name.lower() == "nt":
    from asyncio import set_event_loop_policy, WindowsSelectorEventLoopPolicy
    set_event_loop_policy(WindowsSelectorEventLoopPolicy())


class MiniconfException(Exception):
    """Generic exceptions generated by Miniconf."""


class Miniconf:
    """An asynchronous API for controlling Miniconf devices using MQTT."""

    @classmethod
    async def create(cls, client: Client, broker: str, prefix):
        """Create a connection to the broker and a Miniconf device using it."""
        miniconf = cls(client, broker, prefix)

        return miniconf

    def __init__(self, client: str | Client, broker: str, prefix: str):
        """Constructor.

        Args:
            client: A connected MQTT5 client.
            prefix: The MQTT toptic prefix of the device to control.
        """
        if isinstance(client, str):
            client = Client(client, protocol=MQTTv5, logger=LOGGER)
        self.client = client
        self.prefix = prefix
        self.broker = broker
        self._inflight = {}
        self.response_topic = f"{prefix}/response"
        self._listening_task = asyncio.create_task(self.process_messages())


    async def __aenter__(self):
        self.client.__aenter__()
        await self.subscriptions_complete()
        return self

    async def __aexit__(self, *args, **kwargs):
        self.client.__aexit__(*args, **kwargs)

    async def process_messages(self):
        try:
            async with Client(self.broker, protocol=MQTTv5, logger=LOGGER) as client:
                await client.subscribe(self.response_topic)
                LOGGER.info("listener started")
                async for message in client.messages:
                    try:
                        properties = message.properties.json()
                    except AttributeError:
                        properties = {}

                    LOGGER.debug(f"Received {message.topic}: {message.payload} [{properties}]")

                    # Extract request_id corrleation data from the properties
                    try:
                        request_id = bytes(bytearray.fromhex(properties["CorrelationData"]))
                    except KeyError:
                        LOGGER.info("Discarding message without CD")
                        continue

                    try:
                        ret, fut = self._inflight[request_id]
                    except KeyError:
                        LOGGER.info("Discarding message with unexpected CD: %s", request_id)
                        continue

                    # When receiving data not on the specific response topic, the data is some partial
                    # result of another response. Append it to the data collected for the request.
                    if message.topic.value != self.response_topic:
                        # Payloads for path values are JSON formatted.
                        response = json.loads(message.payload)

                        # Handle get subscription data.
                        ret.append(response)
                        continue

                    # Payloads for generic responses are UTF8
                    response = message.payload.decode("utf-8")

                    try:
                        code = dict(properties["UserProperty"])["code"]
                    except KeyError:
                        LOGGER.warning("Discarding message without response code user property")
                        continue

                    # Otherwise, a request has completed with a result. Check the result code and handle it
                    # appropriately.
                    if code == "Continue":
                        ret.append(response)
                        continue

                    if code == "Ok":
                        if response:
                            ret.append(response)
                        fut.set_result(ret)
                    else:
                        fut.set_exception(
                            MiniconfException(f"Received code: {code}, Message: {response}")
                        )

                    del self._inflight[request_id]
        except Exception as exc:
            LOGGER.error(f"Listener exception: {exc}")
            raise exc
        LOGGER.warn("Listener exitting")

    async def _do(self, topic: str, **kwargs):
        fut = asyncio.get_running_loop().create_future()

        request_id = uuid.uuid1().hex.encode()
        assert request_id not in self._inflight
        self._inflight[request_id] = [], fut

        props = Properties(PacketTypes.PUBLISH)
        props.ResponseTopic = self.response_topic
        props.CorrelationData = request_id

        LOGGER.info(f"Publishing {topic}: {kwargs['payload']}, {props}")
        await self.client.publish(
            topic,
            properties=props,
            **kwargs,
        )
        LOGGER.info("Done")

        return await fut


    async def command(self, *args, **kwargs):
        """Refer to `set()` for more information."""
        warnings.warn(
            "The `command` API function is deprecated in favor of `set()`",
            DeprecationWarning,
        )
        return await self.set(*args, **kwargs)

    async def set(self, path, value, retain=False):
        """Write the provided data to the specified path.

        Args:
            path: The path to set.
            value: The value to set.
            retain: Retain the the setting on the broker.
        """
        ret = await self._do(
            topic=f"{self.prefix}/settings{path}",
            payload=json.dumps(value, separators=(",", ":")),
            retain=retain,
        )
        assert len(ret) == 1
        return ret[0]

    async def list_paths(self):
        """Get a list of all the paths available on the device."""
        return await self._do(topic=f"{self.prefix}/list", payload="")

    async def get(self, path):
        """Get the specific value of a given path.

        Args:
            path: The path to get.
        """
        ret = await self._do(topic=f"{self.prefix}/settings{path}", payload="")
        assert len(ret) == 1
        return ret[0]

    async def clear(self, path):
        """Clear retained value from a path.

        Args:
            path: The path to get.
        """
        await self._do(f"{self.prefix}/settings{path}", payload="", retain=True)
